/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/bitcoinjs-message@2.2.0/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const bs58check=require("bs58check"),bech32=require("bech32"),bufferEquals=require("buffer-equals"),createHash=require("create-hash"),secp256k1=require("secp256k1"),varuint=require("varuint-bitcoin"),SEGWIT_TYPES={P2WPKH:"p2wpkh",P2SH_P2WPKH:"p2sh(p2wpkh)"};function sha256(e){return createHash("sha256").update(e).digest()}function hash256(e){return sha256(sha256(e))}function hash160(e){return createHash("ripemd160").update(sha256(e)).digest()}function encodeSignature(e,r,n,s){return void 0!==s?(r+=8,s===SEGWIT_TYPES.P2WPKH&&(r+=4)):n&&(r+=4),Buffer.concat([Buffer.alloc(1,r+27),e])}function decodeSignature(e){if(65!==e.length)throw new Error("Invalid signature length");const r=e.readUInt8(0)-27;if(r>15||r<0)throw new Error("Invalid signature parameter");return{compressed:!!(12&r),segwitType:8&r?4&r?SEGWIT_TYPES.P2WPKH:SEGWIT_TYPES.P2SH_P2WPKH:null,recovery:3&r,signature:e.slice(1)}}function magicHash(e,r){r=r||"Bitcoin Signed Message:\n",Buffer.isBuffer(r)||(r=Buffer.from(r,"utf8")),Buffer.isBuffer(e)||(e=Buffer.from(e,"utf8"));const n=varuint.encodingLength(e.length),s=Buffer.allocUnsafe(r.length+n+e.length);return r.copy(s,0),varuint.encode(e.length,s,r.length),e.copy(s,r.length+n),hash256(s)}function prepareSign(e,r){"object"==typeof e&&void 0===r&&(r=e,e=void 0);let{segwitType:n,extraEntropy:s}=r||{};if(n&&("string"==typeof n||n instanceof String)&&(n=n.toLowerCase()),n&&n!==SEGWIT_TYPES.P2SH_P2WPKH&&n!==SEGWIT_TYPES.P2WPKH)throw new Error('Unrecognized segwitType: use "'+SEGWIT_TYPES.P2SH_P2WPKH+'" or "'+SEGWIT_TYPES.P2WPKH+'"');return{messagePrefixArg:e,segwitType:n,extraEntropy:s}}function isSigner(e){return e&&"function"==typeof e.sign}function sign(e,r,n,s,t){const{messagePrefixArg:i,segwitType:c,extraEntropy:o}=prepareSign(s,t),a=magicHash(e,i),u=isSigner(r)?r.sign(a,o):secp256k1.sign(a,r,{data:o});return encodeSignature(u.signature,u.recovery,n,c)}function signAsync(e,r,n,s,t){let i,c,o;return Promise.resolve().then((()=>{({messagePrefixArg:i,segwitType:c,extraEntropy:o}=prepareSign(s,t));const n=magicHash(e,i);return isSigner(r)?r.sign(n,o):secp256k1.sign(n,r,{data:o})})).then((e=>encodeSignature(e.signature,e.recovery,n,c)))}function segwitRedeemHash(e){return hash160(Buffer.concat([Buffer.from("0014","hex"),e]))}function decodeBech32(e){const r=bech32.decode(e),n=bech32.fromWords(r.words.slice(1));return Buffer.from(n)}function verify(e,r,n,s,t){Buffer.isBuffer(n)||(n=Buffer.from(n,"base64"));const i=decodeSignature(n);if(t&&!i.compressed)throw new Error("checkSegwitAlways can only be used with a compressed pubkey signature flagbyte");const c=magicHash(e,s),o=hash160(secp256k1.recover(c,i.signature,i.recovery,i.compressed));let a,u;if(i.segwitType)i.segwitType===SEGWIT_TYPES.P2SH_P2WPKH?(a=segwitRedeemHash(o),u=bs58check.decode(r).slice(1)):(a=o,u=decodeBech32(r));else if(t)try{return u=decodeBech32(r),bufferEquals(o,u)}catch(e){const n=segwitRedeemHash(o);return u=bs58check.decode(r).slice(1),bufferEquals(o,u)||bufferEquals(n,u)}else a=o,u=bs58check.decode(r).slice(1);return bufferEquals(a,u)}module.exports={magicHash:magicHash,sign:sign,signAsync:signAsync,verify:verify};
//# sourceMappingURL=/sm/a8d22cfeb70c0830254e929c8ff48973bcdd25cad97400b16bd1bf1636f5874f.map